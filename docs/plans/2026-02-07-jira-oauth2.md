# Jira OAuth 2.0 Authorization Code Flow

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the current Bearer token prompt with a proper OAuth 2.0 Authorization Code flow for Jira Cloud, so users can authenticate with read-only scopes without manually creating or pasting tokens.

**Why:** Jira Cloud's OAuth 2.0 requires the Authorization Code flow (not just pasting a token). The current approach (`Bearer <token>`) fails with 403 because the token must be obtained through the proper exchange. This also lets us request granular, read-only scopes.

**Blocking:** This is the main blocker preventing real Jira API usage.

---

## Background

### Current Auth State

- **Tempo API:** Works with a manually-created API token (Bearer auth). No change needed.
- **Jira API:** Needs OAuth 2.0. Currently prompts for a Bearer token, but Jira Cloud rejects it because tokens must be obtained through the Authorization Code exchange.

### What We Need from Jira

1. `GET /rest/api/2/myself` - fetch the user's `accountId`
2. `GET /rest/api/2/issue/{key}` - fetch the numeric `id` for a ticket key (e.g., `PROJ-123` -> `12345`)

Both are read-only operations. We need scopes: `read:me`, `read:jira-work`.

---

## OAuth 2.0 Authorization Code Flow

```
┌──────────┐     1. open browser      ┌──────────────┐
│  watsup   │ ─────────────────────► │  Atlassian    │
│  CLI      │                         │  Auth Server  │
│           │ ◄──── 4. auth code ──── │               │
│           │  (localhost callback)    │               │
│           │                         │               │
│           │ ───── 5. exchange ────► │               │
│           │  (code → tokens)        │               │
│           │                         │               │
│           │ ◄──── 6. tokens ─────  │               │
│           │  (access + refresh)     │               │
└──────────┘                         └──────────────┘
      │                                     ▲
      │ 1.                                  │ 3. consent
      ▼                                     │
┌──────────┐     2. login/consent     ┌──────────┐
│  Browser  │ ─────────────────────► │  User     │
│           │                         │           │
└──────────┘                         └──────────┘
```

### Step-by-Step

1. **CLI starts a temporary localhost HTTP server** on a random available port (e.g., `http://localhost:9274/callback`)
2. **CLI opens the user's browser** to the Atlassian authorization URL with parameters:
   - `client_id` (from registered OAuth app)
   - `redirect_uri=http://localhost:{port}/callback`
   - `scope=read:me read:jira-work offline_access`
   - `response_type=code`
   - `state={random_nonce}` (CSRF protection)
3. **User logs in to Atlassian** and consents to the requested scopes
4. **Atlassian redirects browser** to `http://localhost:{port}/callback?code={auth_code}&state={nonce}`
5. **CLI receives the callback**, validates the `state` parameter, extracts the `code`
6. **CLI exchanges the code for tokens** via `POST https://auth.atlassian.com/oauth/token`:
   - `grant_type=authorization_code`
   - `client_id`, `client_secret`, `code`, `redirect_uri`
7. **CLI stores** `access_token`, `refresh_token`, and `expires_at` in config
8. **CLI shuts down** the temporary HTTP server

### Token Refresh

Access tokens expire (typically 1 hour). Before each Jira API call:

1. Check if `expires_at` is in the past (or within a 60-second buffer)
2. If expired, `POST https://auth.atlassian.com/oauth/token` with `grant_type=refresh_token`
3. Store the new `access_token`, `refresh_token`, and `expires_at`

---

## Prerequisites (Manual, One-Time)

Before implementing, the app developer must register an OAuth 2.0 app:

1. Go to https://developer.atlassian.com/console/myapps/
2. Create a new OAuth 2.0 app
3. Under **Authorization**, add the callback URL: `http://localhost:9274/callback` (or use a range)
4. Under **Permissions**, add:
   - Jira API: `read:me`, `read:jira-work`
5. Note the `client_id` and `client_secret`

**Decision needed:** How to distribute `client_id` and `client_secret`:
- **Option A:** Hardcode in the binary (common for CLI tools; client_secret is not truly secret for native apps)
- **Option B:** User provides their own OAuth app credentials (more secure, more friction)
- **Option C:** Use PKCE (Proof Key for Code Exchange) which eliminates the need for client_secret entirely

**Recommendation:** Option C (PKCE) is the modern best practice for CLI/native apps. Atlassian supports it.

---

## PKCE Flow (Recommended)

PKCE eliminates the `client_secret` requirement, which is ideal for CLI apps:

1. CLI generates a random `code_verifier` (43-128 character string)
2. CLI computes `code_challenge = BASE64URL(SHA256(code_verifier))`
3. Authorization URL includes `code_challenge` and `code_challenge_method=S256`
4. Token exchange includes `code_verifier` instead of `client_secret`

This means we only need to distribute the `client_id` (which is public).

---

## Implementation Tasks

### Task 1: OAuth Module Skeleton

Create `lib/oauth.ml` and `lib/oauth.mli` with types and helpers.

**Types:**
```ocaml
type oauth_tokens = {
  access_token : string;
  refresh_token : string;
  expires_at : float;  (* Unix timestamp *)
}

type pkce = {
  code_verifier : string;
  code_challenge : string;
}
```

**Functions:**
```ocaml
(* Generate PKCE code_verifier and code_challenge *)
val generate_pkce : unit -> pkce

(* Build the Atlassian authorization URL *)
val authorization_url : client_id:string -> redirect_uri:string -> state:string -> pkce:pkce -> string

(* Exchange auth code for tokens *)
val exchange_code : io:Io.t -> client_id:string -> code:string -> redirect_uri:string -> code_verifier:string -> oauth_tokens Or_error.t

(* Refresh an expired access token *)
val refresh_token : io:Io.t -> client_id:string -> refresh_token:string -> oauth_tokens Or_error.t
```

**Config changes:**
```ocaml
type t = {
  (* ... existing fields ... *)
  jira_access_token : string [@default ""];
  jira_refresh_token : string [@default ""];
  jira_token_expires_at : float [@default 0.0];
  (* Remove: jira_token, jira_email *)
}
```

**Unit tests:**
- `generate_pkce` produces valid lengths
- `authorization_url` builds correct URL with all params
- Token exchange with mocked HTTP (success and error cases)
- Token refresh with mocked HTTP

### Task 2: Localhost Callback Server

Create a temporary Cohttp HTTP server to receive the OAuth callback.

**Implementation:**
```ocaml
(* Start server, return (port, promise_of_auth_code) *)
val start_callback_server : unit -> (int * string Lwt.t) Lwt.t
```

The server:
1. Binds to `127.0.0.1` on port 0 (OS assigns a free port)
2. Listens for a single GET request to `/callback`
3. Validates the `state` parameter matches expected value
4. Extracts the `code` query parameter
5. Responds with a simple HTML page: "Authentication successful! You can close this tab."
6. Resolves the promise with the auth code
7. Shuts down automatically

**Key considerations:**
- Use `Conduit_lwt_unix.init ~src:"127.0.0.1" ()` to bind only to localhost
- Set a timeout (e.g., 120 seconds) so the CLI doesn't hang forever
- Handle the error case where user closes browser without completing auth

**Testing:**
- Unit test: start server, make HTTP request to it, verify code extraction
- Unit test: state mismatch returns error
- Unit test: timeout produces clear error message

### Task 3: Browser Opener

Open the user's default browser to the authorization URL.

**Implementation:**
```ocaml
(* Open URL in default browser. Returns Ok () or Error on failure. *)
val open_browser : io:Io.t -> url:string -> unit Or_error.t
```

Uses `io.run_command` with platform-specific commands:
- macOS: `open "<url>"`
- Linux: `xdg-open "<url>"`

Since we're on macOS, start with `open`. The URL must be shell-quoted.

**Fallback:** If browser opening fails, print the URL and ask the user to open it manually.

**Testing:**
- Mock `run_command` to verify the correct command is constructed
- Test fallback path (print URL when command fails)

### Task 4: Auth Flow Orchestration

Wire everything together in `main_logic.ml`.

**Replace the current Jira token prompt with:**
```
1. Check config for valid (non-expired) jira_access_token
2. If valid token exists → use it
3. If refresh_token exists but access_token expired → refresh
4. If no tokens at all → run full OAuth flow:
   a. Generate PKCE
   b. Generate random state nonce
   c. Start callback server
   d. Build authorization URL
   e. Open browser
   f. Print "Waiting for authorization..." message
   g. Wait for callback (with timeout)
   h. Exchange code for tokens
   i. Save tokens to config
```

**Update `jira_auth_header`:**
```ocaml
let ensure_valid_token ~io ~config ~config_path =
  if token_is_valid config then
    config
  else if has_refresh_token config then
    let tokens = Oauth.refresh_token ~io ... in
    let config = { config with jira_access_token = tokens.access_token; ... } in
    Config.save ~path:config_path config |> Or_error.ok_exn;
    config
  else
    run_full_oauth_flow ~io ~config ~config_path
```

**Testing (E2E):**
- Test with mocked HTTP: full OAuth flow with mocked callback
- Test token refresh path
- Test already-valid token path (no HTTP calls)

### Task 5: Config Migration

Handle the transition from old config format to new.

**Changes:**
- `jira_token` field removed (replaced by `jira_access_token`)
- `jira_email` field removed (no longer needed; `accountId` comes from Jira API)
- New fields: `jira_access_token`, `jira_refresh_token`, `jira_token_expires_at`

**Migration strategy:**
- Use `[@default]` annotations on new fields (already our pattern)
- Old `jira_token` field: keep in type with `[@default ""]`, ignore during auth
- On first run after upgrade: user will be prompted to re-authenticate via OAuth
- Print a one-time message: "Jira authentication has been upgraded to OAuth 2.0. Please re-authenticate."

**Testing:**
- Load old config format, verify it loads without error
- Verify OAuth flow triggers when old token fields are present but new ones are empty

### Task 6: Client ID Distribution

**Decision:** How to embed the `client_id`.

**Recommended approach:**
- Hardcode `client_id` in the source (it's public for PKCE apps)
- Allow override via environment variable `WATSUP_JIRA_CLIENT_ID` for development/testing
- No `client_secret` needed (PKCE)

```ocaml
let jira_client_id =
  match Sys.getenv "WATSUP_JIRA_CLIENT_ID" with
  | Some id -> id
  | None -> "your-registered-client-id-here"
```

---

## Testing Strategy

### Unit Tests (in `lib/oauth.ml`)

```ocaml
let%expect_test "generate_pkce produces valid verifier" = ...
let%expect_test "authorization_url includes all params" = ...
let%expect_test "exchange_code with successful response" = ...
let%expect_test "exchange_code with error response" = ...
let%expect_test "refresh_token with successful response" = ...
```

### E2E Tests (in `test/test_e2e.ml`)

```ocaml
let%expect_test "full OAuth flow with mocked HTTP" = ...
let%expect_test "uses cached valid token without HTTP" = ...
let%expect_test "refreshes expired token" = ...
let%expect_test "handles OAuth error gracefully" = ...
```

### Manual Testing

Update `scripts/test-cli.sh` with an `oauth` mode:
```bash
./scripts/test-cli.sh oauth   # Test OAuth flow against real Atlassian
./scripts/test-cli.sh real    # Test full workflow with real APIs
```

---

## Dependencies

May need to add:
- `mirage-crypto-rng` - for generating random `code_verifier` and `state` (or use `Core.Random`)
- `base64` - for BASE64URL encoding (or use `Core.Base64`)
- `digestif` or `mirage-crypto` - for SHA256 hashing

Check if Core already provides these before adding new deps.

---

## Risks and Open Questions

1. **Port conflicts:** The callback server uses a random port, but the OAuth app's registered redirect URIs must include it. Atlassian allows `http://localhost` with any port for native apps - verify this.

2. **Firewall/proxy:** Some corporate environments may block localhost HTTP servers. Fallback: manual copy-paste of the auth code (Atlassian provides an "out-of-band" option for some apps).

3. **Token storage security:** Tokens are stored in plaintext in `config.sexp`. Consider:
   - File permissions (`0600`)
   - macOS Keychain integration (future enhancement)
   - `.gitignore` the config directory

4. **Atlassian accessible resources:** After OAuth, need to call `GET https://api.atlassian.com/oauth/token/accessible-resources` to get the `cloudId` for the user's Jira instance, then use `https://api.atlassian.com/ex/jira/{cloudId}/rest/api/2/...` for API calls. This is different from the current direct URL approach.

5. **Multiple Jira sites:** A user may have access to multiple Atlassian sites. Need to handle site selection if more than one is returned by accessible-resources.

---

## Execution Order

```
Task 1 (OAuth module)
  └─► Task 2 (Callback server)
        └─► Task 3 (Browser opener)
              └─► Task 4 (Orchestration)  ← most complex, do last
Task 5 (Config migration) ← can be done in parallel with Tasks 1-3
Task 6 (Client ID) ← do after registering the app
```

**Estimated commits:** 4-6 (one per task, some may combine)

---

## Reference: Atlassian OAuth 2.0 Endpoints

| Endpoint | URL |
|----------|-----|
| Authorize | `https://auth.atlassian.com/authorize?audience=api.atlassian.com&client_id={id}&scope={scopes}&redirect_uri={uri}&state={state}&response_type=code&prompt=consent&code_challenge={challenge}&code_challenge_method=S256` |
| Token exchange | `POST https://auth.atlassian.com/oauth/token` |
| Accessible resources | `GET https://api.atlassian.com/oauth/token/accessible-resources` |
| Jira API (via cloud) | `https://api.atlassian.com/ex/jira/{cloudId}/rest/api/2/...` |

### Token Exchange Request Body

```json
{
  "grant_type": "authorization_code",
  "client_id": "{client_id}",
  "code": "{auth_code}",
  "redirect_uri": "{redirect_uri}",
  "code_verifier": "{code_verifier}"
}
```

### Token Refresh Request Body

```json
{
  "grant_type": "refresh_token",
  "client_id": "{client_id}",
  "refresh_token": "{refresh_token}"
}
```
